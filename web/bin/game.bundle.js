webpackJsonp([0],{

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n__webpack_require__(1); // for browser compatibility\n__webpack_require__(2); // for browser compatibility\nvar React = __webpack_require__(299);\nvar ReactDOM = __webpack_require__(329);\nvar Board = __webpack_require__(498);\n\nvar BoardView = function (_React$Component) {\n  _inherits(BoardView, _React$Component);\n\n  function BoardView(props) {\n    _classCallCheck(this, BoardView);\n\n    var _this = _possibleConstructorReturn(this, (BoardView.__proto__ || Object.getPrototypeOf(BoardView)).call(this, props));\n\n    _this.state = { board: new Board() };\n    return _this;\n  }\n\n  _createClass(BoardView, [{\n    key: 'restartGame',\n    value: function restartGame() {\n      this.setState({ board: new Board() });\n    }\n  }, {\n    key: 'handleKeyDown',\n    value: function handleKeyDown(event) {\n      if (this.state.board.hasWon()) {\n        return;\n      }\n      if (event.keyCode >= 37 && event.keyCode <= 40) {\n        event.preventDefault();\n        var direction = event.keyCode - 37;\n        this.setState({ board: this.state.board.move(direction) });\n      }\n    }\n  }, {\n    key: 'handleTouchStart',\n    value: function handleTouchStart(event) {\n      if (this.state.board.hasWon()) {\n        return;\n      }\n      if (event.touches.length != 1) {\n        return;\n      }\n      this.startX = event.touches[0].screenX;\n      this.startY = event.touches[0].screenY;\n      event.preventDefault();\n    }\n  }, {\n    key: 'handleTouchEnd',\n    value: function handleTouchEnd(event) {\n      if (this.state.board.hasWon()) {\n        return;\n      }\n      if (event.changedTouches.length != 1) {\n        return;\n      }\n      var deltaX = event.changedTouches[0].screenX - this.startX;\n      var deltaY = event.changedTouches[0].screenY - this.startY;\n      var direction = -1;\n      if (Math.abs(deltaX) > 3 * Math.abs(deltaY) && Math.abs(deltaX) > 30) {\n        direction = deltaX > 0 ? 2 : 0;\n      } else if (Math.abs(deltaY) > 3 * Math.abs(deltaX) && Math.abs(deltaY) > 30) {\n        direction = deltaY > 0 ? 3 : 1;\n      }\n      if (direction != -1) {\n        this.setState({ board: this.state.board.move(direction) });\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      window.addEventListener('keydown', this.handleKeyDown.bind(this));\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      window.removeEventListener('keydown', this.handleKeyDown.bind(this));\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var cells = this.state.board.cells.map(function (row, rowIndex) {\n        return React.createElement(\n          'div',\n          { key: rowIndex },\n          row.map(function (_, columnIndex) {\n            return React.createElement(Cell, { key: rowIndex * Board.size + columnIndex });\n          })\n        );\n      });\n      var tiles = this.state.board.tiles.filter(function (tile) {\n        return tile.value != 0;\n      }).map(function (tile) {\n        return React.createElement(TileView, { tile: tile, key: tile.id });\n      });\n      return React.createElement(\n        'div',\n        { className: 'board', onTouchStart: this.handleTouchStart.bind(this), onTouchEnd: this.handleTouchEnd.bind(this), tabIndex: '1' },\n        cells,\n        tiles,\n        React.createElement(GameEndOverlay, { board: this.state.board, onRestart: this.restartGame.bind(this) })\n      );\n    }\n  }]);\n\n  return BoardView;\n}(React.Component);\n\n;\n\nvar Cell = function (_React$Component2) {\n  _inherits(Cell, _React$Component2);\n\n  function Cell() {\n    _classCallCheck(this, Cell);\n\n    return _possibleConstructorReturn(this, (Cell.__proto__ || Object.getPrototypeOf(Cell)).apply(this, arguments));\n  }\n\n  _createClass(Cell, [{\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate() {\n      return false;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return React.createElement(\n        'span',\n        { className: 'cell' },\n        ''\n      );\n    }\n  }]);\n\n  return Cell;\n}(React.Component);\n\n;\n\nvar TileView = function (_React$Component3) {\n  _inherits(TileView, _React$Component3);\n\n  function TileView() {\n    _classCallCheck(this, TileView);\n\n    return _possibleConstructorReturn(this, (TileView.__proto__ || Object.getPrototypeOf(TileView)).apply(this, arguments));\n  }\n\n  _createClass(TileView, [{\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate(nextProps) {\n      if (this.props.tile != nextProps.tile) {\n        return true;\n      }\n      if (!nextProps.tile.hasMoved() && !nextProps.tile.isNew()) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var tile = this.props.tile;\n      var classArray = ['tile'];\n      classArray.push('tile' + this.props.tile.value);\n      if (!tile.mergedInto) {\n        classArray.push('position_' + tile.row + '_' + tile.column);\n      }\n      if (tile.mergedInto) {\n        classArray.push('merged');\n      }\n      if (tile.isNew()) {\n        classArray.push('new');\n      }\n      if (tile.hasMoved()) {\n        classArray.push('row_from_' + tile.fromRow() + '_to_' + tile.toRow());\n        classArray.push('column_from_' + tile.fromColumn() + '_to_' + tile.toColumn());\n        classArray.push('isMoving');\n      }\n      var classes = classArray.join(' ');\n      return React.createElement(\n        'span',\n        { className: classes },\n        tile.value\n      );\n    }\n  }]);\n\n  return TileView;\n}(React.Component);\n\nvar GameEndOverlay = function GameEndOverlay(_ref) {\n  var board = _ref.board,\n      onRestart = _ref.onRestart;\n\n  var contents = '';\n  if (board.hasWon()) {\n    contents = 'Good Job!';\n  } else if (board.hasLost()) {\n    contents = 'Game Over';\n  }\n  if (!contents) {\n    return null;\n  }\n  return React.createElement(\n    'div',\n    { className: 'overlay' },\n    React.createElement(\n      'p',\n      { className: 'message' },\n      contents\n    ),\n    React.createElement(\n      'button',\n      { className: 'tryAgain', onClick: onRestart, onTouchEnd: onRestart },\n      'Try again'\n    )\n  );\n};\n\nReactDOM.render(React.createElement(BoardView, null), document.getElementById('boardDiv'));\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0\n//# sourceURL=webpack:///./src/index.js?");

/***/ },

/***/ 498:
/***/ function(module, exports) {

	eval("\"use strict\";\n\nvar rotateLeft = function rotateLeft(matrix) {\n  var rows = matrix.length;\n  var columns = matrix[0].length;\n  var res = [];\n  for (var row = 0; row < rows; ++row) {\n    res.push([]);\n    for (var column = 0; column < columns; ++column) {\n      res[row][column] = matrix[column][columns - row - 1];\n    }\n  }\n  return res;\n};\n\nvar Tile = function Tile(value, row, column) {\n  this.value = value || 0;\n  this.row = row || -1;\n  this.column = column || -1;\n  this.oldRow = -1;\n  this.oldColumn = -1;\n  this.markForDeletion = false;\n  this.mergedInto = null;\n  this.id = Tile.id++;\n};\n\nTile.id = 0;\n\nTile.prototype.moveTo = function (row, column) {\n  this.oldRow = this.row;\n  this.oldColumn = this.column;\n  this.row = row;\n  this.column = column;\n};\n\nTile.prototype.isNew = function () {\n  return this.oldRow == -1 && !this.mergedInto;\n};\n\nTile.prototype.hasMoved = function () {\n  return this.fromRow() != -1 && (this.fromRow() != this.toRow() || this.fromColumn() != this.toColumn()) || this.mergedInto;\n};\n\nTile.prototype.fromRow = function () {\n  return this.mergedInto ? this.row : this.oldRow;\n};\n\nTile.prototype.fromColumn = function () {\n  return this.mergedInto ? this.column : this.oldColumn;\n};\n\nTile.prototype.toRow = function () {\n  return this.mergedInto ? this.mergedInto.row : this.row;\n};\n\nTile.prototype.toColumn = function () {\n  return this.mergedInto ? this.mergedInto.column : this.column;\n};\n\nvar Board = function Board() {\n  console.log(\"test\");\n  this.tiles = [];\n  this.cells = [];\n  for (var i = 0; i < Board.size; ++i) {\n    this.cells[i] = [this.addTile(), this.addTile(), this.addTile(), this.addTile()];\n  }\n  this.addRandomTile();\n  this.setPositions();\n  this.won = false;\n};\n\nBoard.prototype.addTile = function () {\n  var res = new Tile();\n  Tile.apply(res, arguments);\n  this.tiles.push(res);\n  return res;\n};\n\nBoard.size = 4;\n\nBoard.prototype.moveLeft = function () {\n  var hasChanged = false;\n  for (var row = 0; row < Board.size; ++row) {\n    var currentRow = this.cells[row].filter(function (tile) {\n      return tile.value != 0;\n    });\n    var resultRow = [];\n    for (var target = 0; target < Board.size; ++target) {\n      var targetTile = currentRow.length ? currentRow.shift() : this.addTile();\n      if (currentRow.length > 0 && currentRow[0].value == targetTile.value) {\n        var tile1 = targetTile;\n        targetTile = this.addTile(targetTile.value);\n        tile1.mergedInto = targetTile;\n        var tile2 = currentRow.shift();\n        tile2.mergedInto = targetTile;\n        targetTile.value += tile2.value;\n      }\n      resultRow[target] = targetTile;\n      this.won |= targetTile.value == 2048;\n      hasChanged |= targetTile.value != this.cells[row][target].value;\n    }\n    this.cells[row] = resultRow;\n  }\n  return hasChanged;\n};\n\nBoard.prototype.setPositions = function () {\n  this.cells.forEach(function (row, rowIndex) {\n    row.forEach(function (tile, columnIndex) {\n      tile.oldRow = tile.row;\n      tile.oldColumn = tile.column;\n      tile.row = rowIndex;\n      tile.column = columnIndex;\n      tile.markForDeletion = false;\n    });\n  });\n};\n\nBoard.fourProbability = 0.1;\n\nBoard.prototype.addRandomTile = function () {\n  var emptyCells = [];\n  for (var r = 0; r < Board.size; ++r) {\n    for (var c = 0; c < Board.size; ++c) {\n      if (this.cells[r][c].value == 0) {\n        emptyCells.push({ r: r, c: c });\n      }\n    }\n  }\n  var index = ~~(Math.random() * emptyCells.length);\n  var cell = emptyCells[index];\n  var newValue = Math.random() < Board.fourProbability ? 4 : 2;\n  this.cells[cell.r][cell.c] = this.addTile(newValue);\n};\n\nBoard.prototype.move = function (direction) {\n  // 0 -> left, 1 -> up, 2 -> right, 3 -> down\n  this.clearOldTiles();\n  for (var i = 0; i < direction; ++i) {\n    this.cells = rotateLeft(this.cells);\n  }\n  var hasChanged = this.moveLeft();\n  for (var i = direction; i < 4; ++i) {\n    this.cells = rotateLeft(this.cells);\n  }\n  if (hasChanged) {\n    this.addRandomTile();\n  }\n  this.setPositions();\n  return this;\n};\n\nBoard.prototype.clearOldTiles = function () {\n  this.tiles = this.tiles.filter(function (tile) {\n    return tile.markForDeletion == false;\n  });\n  this.tiles.forEach(function (tile) {\n    tile.markForDeletion = true;\n  });\n};\n\nBoard.prototype.hasWon = function () {\n  return this.won;\n};\n\nBoard.deltaX = [-1, 0, 1, 0];\nBoard.deltaY = [0, -1, 0, 1];\n\nBoard.prototype.hasLost = function () {\n  var canMove = false;\n  for (var row = 0; row < Board.size; ++row) {\n    for (var column = 0; column < Board.size; ++column) {\n      canMove |= this.cells[row][column].value == 0;\n      for (var dir = 0; dir < 4; ++dir) {\n        var newRow = row + Board.deltaX[dir];\n        var newColumn = column + Board.deltaY[dir];\n        if (newRow < 0 || newRow >= Board.size || newColumn < 0 || newColumn >= Board.size) {\n          continue;\n        }\n        canMove |= this.cells[row][column].value == this.cells[newRow][newColumn].value;\n      }\n    }\n  }\n  return !canMove;\n};\nmodule.exports.Board = Board;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/board.js\n// module id = 498\n// module chunks = 0\n//# sourceURL=webpack:///./src/board.js?");

/***/ }

});